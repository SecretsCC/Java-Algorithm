# Java内存区域

# 常见面试题

### 基本问题

 - 介绍下Java内存区域(运行时数据区)
 - Java对象创建过程(五步)
 - 对象的访问定位的两种方式(句柄和直接指针)

### 拓展问题

- String类和常量池
- 8中基本类型的包装类和常量池



## 1. Java内存区域

​	Java程序员把内存的控制权利交给Java虚拟机

​		![Image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/Screen%20Shot%202019-07-08%20at%207.10.21%20AM.png>)

​			![Image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/Screen%20Shot%202019-07-08%20at%207.10.30%20AM.png>)

__线程私有__:										 __线程共享__:

​	程序计数器	program counter Register			堆		    Heap

​	虚拟机栈	    VM stack						      方法区	    Method Area

​	本地方法栈	 Native Method Stack				直接内存	Direct Memory

***

1. __程序计数器__

   ​	程序计数器是一块较小的内存空间, 看做当前线程所执行的字节码的行号指示器.

   ​	__字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令__,分支,循环,跳转,异常处理,线程恢复等功能都需要依赖这个计数器来完成.

   ​	为了线程切换后能恢复到正确的执行位置,每条线程都需要有一个独立的程序计数器,各线程之间计数器互不影响,独立存储,我们称这类内存区域为"线程私有"的内存__(记录当前线程执行的位置, 从而当线程切换回来的时候能够知道该线程上次运行到哪)__

   __注意: 程序计数器是唯一一个不会出现OutOfMemoryError的内存区域, 它的生命周期随着线程的创建而创建, 随着线程的结束而死亡__

2. __Java虚拟机__

   ​	Java虚拟机也是线程私有的,生命周期和线程相同,描述的是Java方法执行的内存模型,每次方法调用的数据通过栈传递

   ​	Java内存粗糙的分为堆内存(Heap)和栈内存(Stack), 栈就是虚拟机栈, 或者说虚拟机栈局部变量表.

   ​	局部变量表主要存放了编译器可知的各种__数据类型(boolean, byte, char,short,int,float,long,double), 对象引用__(reference类型, 不同于对象本身, 可能是一个指向对象起始地址的引用指针, 也可能是指向一个代表对象的句柄或其他与此对象相关的位置)

   ​	Java虚拟机栈会出现__两种异常__: 

   ​		__StackOverFlowError__: 若Java虚拟机栈内存大小不允许动态拓展, 当线程请求栈的深度超过当前虚拟机栈最大深度抛出异常

   ​		__OutOfMemoryError__: 若Java虚拟机栈的内存大小允许动态拓展, 且当线程请求栈内存用完, 无法再动态扩展,抛出异常

   ​	

   ​	Java栈可用类比数据结构的栈, Java栈中保存的主要内容是栈帧, 每一次函数调用都会有一个对象的栈帧压入栈, 调用结束后弹出. __两种返回方式__: 1. return语句 2.抛出异常

3. __本地方法栈__

   ​	和虚拟机栈所发挥的作用非常相似, 区别是: 虚拟机栈为虚拟机执行Java方法(字节码)服务, 本地方法栈则为虚拟机使用到的Native方法服务

   ​	本地方法被执行的时候, 本地方法栈也会创建一个栈帧, 用于存放局部变量,操作数栈,动态链接,出口信息

4. __堆__

   ​	Java虚拟机所管理内存中最大的一块, 堆是所有线程共享的一块内存区域,在虚拟机启动时创建. __此内存区域的唯一目的就是存放对象实例,几乎所有的对象实例以及数组都在这里分配内存__

   ​	堆是垃圾收集管理的主要区域,也被称为GC堆(__Garbage Collected Heap__), 分代垃圾收集算法, 所以还可以细分为: 新生代和老年代 __进一步划分的目的是更好的回收内存, 或者更快的分配内存__ 

   ​	eden | s0 | s1 | tentired 

   ​	eden,s0,s1属于新生代, tentired属于老年代.

5. __方法区__

   ​	和堆一样, 是线程共享区域, 用于存储已被虚拟机加载的类信息,常量,静态变量,即时编译器编译后的代码等数据. 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分,但它有个别名叫Non-Heap

6. __运行时常量池__

   ​	运行时常量池是方法区的一部分. Class文件中除了有类的版本、字段、方法、接口等描述信息外,还有常量池信息(用于存放编译期生成的各种字面量和符号的引用)

   ​	既然是方法区的一部分,自然受到方法区的限制,当无法申请到内存时抛出OutOfMemoryError异常

   ​	__JDK1.7之后版本的 JVM已经将运行时常量池从方法区中移了出来, 在Java堆中开辟了一块区域存放运行时常量池

7. __直接内存__

   ​	**直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。**

   

