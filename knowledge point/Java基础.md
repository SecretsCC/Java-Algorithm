# Java基础

##面向对象和面向过程的区别

​	**面向过程:** 性能比面向对象高. 因为类调用时需要实例化, 开销比较大,比较消耗资源所以当性能是最重要的考量因素时,比如单片机,嵌入式,Linux/Unix等一般采用面向过程开发. 但是面向过程没有面向对象易维护

​	**面向对象:** 面向对象易维护,易复用,易拓展. 因为面向对象有**封装、继承、多态性** 所以可以设计出低耦合,使系统更加灵活,易于维护. 但是性能会降低



## JVM/JDK/JRE

JVM是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现, 目的是使用相同字节码得到相同的结果.

JDK是Java Development Kit, 是功能齐全的SDK, 拥有JRE所有的一切,还有编译器javac和工具javadoc和jdb,能够创建和编译程序

JRE是Java运行时环境



## Java和C++的区别

- 都是面向对象语言,支持封装继承和多态
- Java不提供指针来直接访问内存,程序内存更安全
- Java类是单继承的,C++支持多重继承; 但是Java接口可以多继承
- Java有自动内存管理机制,不需要程序员手动释放无用内存



## 字符型常量和字符串常量的区别

 	1. 形式上: 字符常量是单引号引起的一个字符; 字符串是双引号引起的若干个字符
 	2. 含义上: 祖父穿相当于一个整型值, 可以参加表达式运算;字符串代表一个地址(该字符串在内存中存放的地方)
 	3. 占内存大小:字符常量只占2字节;字符串常量占若干个字节(至少一个字符结束标志)



## 重载和重写

 - **重载:** 发生在同一个类中,方法名相同.参数类型不同、个数不同、顺序不同,方法返回值和访问修饰符可以不同
 - **重写:** 发生在父子类中,方法名、参数列表必须相同,返回值范围小于等于父类,抛出的异常范围小于等于父类,访问修饰符范围大于等于父类;如果父类方法访问修饰符为private则子类不能重写该昂发





## Java面向对象三大特征

### 封装

​	封装把一个对象的属性私有化,同时提供一些可以被外界访问的属性和方法,如果属性不想被外界访问,我们可以不提供方法给外界访问. 但是如果一个类没有提供给外界访问的方法,那么这个类也没有意义。



### 继承

​	继承是使用已存在的类的定义作为基础建立新类的技术,新类的定义可以增加新的数据或者新的功能,也可以用父类的功能,但不能选择性地继承父类。通过使用继承我们能够非常方便的使用复用以前的代码

##### 	关于继承如下3点请记住:

  		1. 子类拥有父类对象所有的属性和方法(包括私有属性和私有方法),但是父类中的私有属性和方法无法访问,只能拥有
  		2. 子类可以拥有自己的属性和方法,即子类可以对父类进行扩展
  		3. 子类可以用自己的方式实现父类的方法



### 多态

​	多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程式并不确定,而是在程勋运行期间才确定,即一个引用变量到底会指向哪个类的实例对象,该引用变量发出的方法调用到底是哪个类中实现的方法,必须由程序运行期间才能决定

​	在Java中有两种方式可以实现多态:**继承(多个子类对同一方法的重写)和接口(实现接口并覆盖接口中同一方法)**



## String、StringBuffer和StringBuilder的区别是什么

**可变性**

​	简单来说:String类中使用final关键字修饰字符数组来保存字符串,所以String对象是不可变的。

​	而StringBuilder和StringBuffer都继承自AbstractStringBuilder类,在该类中也用字符数组保存字符串,但是没有final关键字修饰,所以可变



**线程安全性**

​	String中对象不可变,理解为常量,线程安全.AbstractStringBuilder定义了一些字符串的基本操作, 如expandCapacity、append、insert、indexOf、等公共方法。StringBuffer对方法加了同步锁或者对调用的方法加了同步锁,所以线程是安全的. StringBuilder并没有加同步锁,所以非线程安全

**性能**

​	每次对String类型进行改变时,都生成一个新的String对象,然后将指针指向新的对象. StringBuffer对对象本身进行操作,不生成新的对象. 相同情况下StringBuilder相比使用StringBuffer仅能获得10%-15%的性能提升,但要冒线多线程 不安全的风险

​	**对三者使用总结:**

​			1.操作少量数据用String

​			2.单线程操作字符串缓冲区下操作大量数据:适用StringBuilder

​			3.多线程操作字符串缓冲区下操作大量数据:使用StringBuffer

## 自动装箱(boxing)与拆箱(unboxing)

​	**装箱:** 将基本类型用它们对应的引用类型包装起来

​	**拆箱:**将包装类型转换为基本数据类型



## 在一个静态方法内调用一个非静态成员为什么是非法的

​	由于静态方法可以不通过对象进行调用,因此在静态方法里,不能调用其他非静态变量,也不可以访问费静态变量成员



## 在Java中定义一个不做事且没有参数的构造方法的作用

​	Java程序在执行子类的构造方法之前,如果没有用Super()来调用父类特定的构造方法,则会调用父类中"没有参数的构造方法"。因此,如果父类中只定义了有参数的构造方法, 而在子类的构造方法中没有用super()来调用父类中特定的构造方法,则编译时将发生错误



## 接口和抽象类的区别是什么

​	1.接口的方法默认是public,所有方法在接口中不能有实现(Java8 开始接口方法可以有默认实现), 而抽象类可以有非抽象的方法

​	2.接口中除了static,final变量,不能有其他变量,而抽象类中则不一定

​	3.一个类可以实现多个接口,但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口

​	4.接口方法默认修饰符是Public, 抽象方法可以有Public、protected和default这些修饰符(抽象方法就是为了被重写所以不能使用Private关键字修饰)

​	5.从设计层面来说,抽象是对类的抽象,是一种模板设计,而接口是对行为的抽象,是一种行为的规范



## 成员变量和局部变量

​	1.从语法形式上看: 成员变量属于类,局部变量是在方法中定义的变量或是方法的参数;成员变量可以被public,private,static等修饰符所修饰,而局部变量不能被访问控制修饰符及static所修饰;但是,成员变量和局部变量都能被final所修饰

​	2.从变量在内存中的存储方式来看:如果成员变量使用static修饰,那么这个成员变量属于类的,如果没有static修饰, 这个成员变量属于实例的。而对象存在于堆内存,局部变量则存在于栈内存

​	3.从变量在内存中生存的时间上看:成员变量是对象的一部分,随着对象的创建而存在,而拒不变量随着方法的调用而自动消失

​	4.成员变量如果没有被赋初值:则会自动以类型的默认值而赋值,而拒不变量则不会自动赋值



## 创建一个对象用什么运算符?对象实体与对象引用有何不同

​	new 运算符, new创建对象实例,对象引用指向对象实例(对象引用存放在栈内存中)。一个对象引用可以指向0个或1个对象; 一个对象可以有n个引用指向它



## 什么是方法的返回值?返回值在类的方法里的作用是什么

​	方法的返回值是我们获取到某个方法中代码执行后产生的结果。返回值的作用接收出结果,使得它可以用于其他的操作



## 一个类的构造方法作用是什么?若一个类没有生命构造方法,该程序能正确执行吗?为什么?

​	主要作用是完成对类对象的初始化工作。可以执行,因为一个类即使没有生命构造方法也会有默认的不带参数的构造方法



## 构造方法有哪些特征

​	1.名字与类名相同

​	2.没有返回值,但不能用void声明构造函数

​	3.生成类的对象时自动执行,无需调用



## 静态方法和实例方法有何不同 

​	1.在外部调用静态方法时, 可以使用"类名.方法名"的方式,也可以使用"对象名.方法名"的方式。而实例方法只有后面这种方式。也就是说,调用静态方法可以无需创建对象

​	2.静态方法在访问本类的成员时,值允许访问静态成员(即静态成员变量和静态方法),而不允许访问实例成员变量和实例方法;实例方法则无此限制



## ==与equals

​	==: 作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象(基本数据类型==比较的是值,引用数据类型==比较的是内存地址)

​	equals(): 作用是判断两个对象是否相等,一般有两种使用情况:

  - 情况1: 类没有覆盖equals()方法,则通过equals()比较两个对象时,等价于==
  - 情况2: 类覆盖了equals()方法, 一般通过覆盖equals()方法比较两个对象的内容是否相等, 若内容相等返回true

String中的equals方法是被从写过的,比较的是对象的值



## hashCode与equals

**为什么重写equals时必须重写hashCode?**

**hashCode()介绍:**

​	hashCode是获取哈希码,也成为散列码;实际上返回的是一个int整数,作用是确定该对象在哈希表中索引位置

​	散列表是键值对,能根据键快速检索出值

**为什么要有hashCode**

​	HashSet通过hashcode来判断对象有没有重复出现,如果有相同的hashcode对象,会调用equals()方法检查两个对象是否真的相同,如果相同,HashSet不会让其加入,如果不同,会散列到其他位置。这样大大减少了equals的次数,提高了运行的执行速度



#### hashCode()和equals()的相关规定

1. 如果两个对象相等,则hashcode一定相同
2. 两个对象相等,调用equals方法都返回true
3. 两个对象有相同的hashcode不一定是相等的
4. **如果equals被覆盖过,hashCode也必须被覆盖过**
5. hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashcode(),则该class的两个对象无论如何都不会相等



## 线程、程序、进程的基本概念以及关系

​	线程与进程相似, 但线程比进程更小的执行单位。一个进程在其执行过程中可以产生多个线程。

​	与进程不同的是同类的多个线程共享同一块内存空间和一组系统资源,所以系统在产生一个线程,或在各个线程之间切换工作时,负担要比进程小得多



​	**程序**是含有指令和数据的文件,被存储在磁盘或其他的数据存储设备中,也就是说程序是静态的代码

​	**进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。简单来说，一个进程就是一个执行中的程序，它在计算机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如CPU时间，内存空间，文件，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存中。 线程是进程划分成的更小的运行单位。线程和进程最大的不同在于基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同时执行一个以上的程序段。



## 线程基本状态

​	![Image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/Thread%20state.png>)

​	

## Final关键字的总结

主要用在三个地方:变量、方法、类

 	1. 对于基本数据类型,一旦初始化之后便不能更改;如果引用类型的变量, 则在初始化之后不能再让其指向另一个对象
 	2. 修饰一个类时,表示这个类不能被继承。final类中所有成员方法都会被隐式的指定为final的方法
 	3. 使用final方法的原因有两个: 第一个是把方法锁定,以防任何继承类修改;第二个是为了效率。



## 异常处理

​	![Image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/exception%20handling.png>)

​	所有异常都有一个共同的祖先java.lang包中的Throwable类。**Throwable**有两个重要的子类**Exception**和**Error**

​	**Error:是程序无法处理的错误**, 表示运行应用程序中较严重的问题。JVM一般会选择线程终止

​	**Exception:**是程序本身可以处理的异常

​	用try,catch,finally块来处理异常

- **try 块：**用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。
- **catch 块:** 用于处理try捕获到的异常。
- **finally 块：**无论是否捕获或处理异常，finally块里的语句都会被执行。当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行。

	#### Throwable类常用方法

​	public string getMessage():返回异常发生时的详细信息

​	public string toString(): 返回异常发生时的简要描述

​	public string getLocalizedMessage():返回异常对象的本地化信息

​	public void printStackTrace(): 在控制台上打印Throwable对象封装的异常信息



## Java序列化中如果有些字段不想序列化怎么办

对于不想序列化的变量,使用transient关键字修饰



## 获取键盘输入常用的两种方法

 1. 通过Scanner

    ```java
    Scanner input = new Scanner(System.in);
    String s  = input.nextLine();
    input.close();
    ```

2. 通过BufferReader

   ```java
   BufferedReader input = new BufferedReader(new InputStreamReader(System.in)); 
   String s = input.readLine(); 
   ```



## Java中IO流分为几种?BIO,NIO,AIO区别

- 按照流向分,分为输入流和输出流

- 按照操作单元划分, 划分为字节流和字符流

- 按照流的角色划分为节点流和处理流

  ![Image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/stream.png>)

  ![Image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/stream2.png>)

  **BIO(Blocking I/O)**:

  **NIO(New I/O)**:

  **AIO(Asynchronous I/O)**: 



## 常见关键字总结

	### Static关键字

​	四种使用场景:

  		1. **修饰成员变量和成员方法:** 被static修饰的成员属于类,不属于这个类的某个对象,被类中所有对象共享,可以并且建议通过类名调用。被static声明的成员变量属于静态成员变量,存放在java内存区域的方法区
  		2. **静态代码块:** 静态代码块定义在类中方法外,静态代码块在非静态代码块之前执行(静态代码块->非静态代码块->构造方法),该类不管创建多少对象,静态代码块只执行一次
  		3. **静态内部类(static修饰类的话只能修饰内部类):** 静态内部类与非静态内部类之间一个最大的区别: 非静态内部类在编译完成之后会隐含的保存着一个引用,该引用指向创建它的外围类,但是静态内部类却没有。没有这个引用就意味着: 1.它的创建是不需要外围类的创建 2.他不能使用任何外围类的非静态成员变量和方法
  		4. **静态导包:** import static 这两个关键字连用可以导入某个类中指定静态资源,并且不需要使用类名调用类中静态成员,可以直接使用类中静态成员变量和成员方法



### This关键字

​	this关键字用于应用类的当前实例

```java
class Manager {
    Employees[] employees;
     
    void manageEmployees() {
        int totalEmp = this.employees.length;
        System.out.println("Total employees: " + totalEmp);
        this.report();
    }
     
    void report() { }
}
```

此关键字可选,如果上面的实例在不适用此关键字的情况下表现相同。但是,使用此关键字可能会更易读或易懂



### Super关键字

​	super关键字用于从子类访问父类的变量和方法

```java
public class Super {
    protected int number;
     
    protected showNumber() {
        System.out.println("number = " + number);
    }
}
 
public class Sub extends Super {
    void bar() {
        super.number = 10;
        super.showNumber();
    }
}
```

- 在构造器中使用 `super（）` 调用父类中的其他构造方法时，该语句必须处于构造器的首行，否则编译器会报错。另外，this 调用本类中的其他构造方法时，也要放在首行。
- this、super不能用在static方法中。