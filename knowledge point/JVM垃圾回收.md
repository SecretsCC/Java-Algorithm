# JVM垃圾回收

## 常见面试题

 - 如何判断对象是否死亡(两种方法)
 - 强引用,弱引用,虚引用(弱引用与虚引用的区别,使用软引用带来的好处)
 - 如何判断一个常量是废弃常量
 - 如何判断一个类是无用的类
 - 垃圾收集有哪些算法,各自的特点
 - HotSpot为什么要分新生代和老年代
 - 常见的垃圾回收器有哪些
 - 介绍CMS,G1收集器
 - Minor Gc和Full GC有什么不同



## JVM内存分派与回收

​	内存自动管理主要真对对象内存回收和对象内存的分配, 核心功能是堆内存中对象的分配与回收

​	现在的收集器基本采用分代垃圾收集算法, Java堆细分为新生代和老年代, 在细致一点有Eden空间, From survivor, To survivor空间等, 进一步划分目的是更好的回收内存,或者更快的分配内存

​	__常见分配策略__

  		1. 对象优先在eden区分配
  		2. 大对象直接进入老年代
  		3. 长期存活的对象将进入老年代



#### 1. 对象优先在Eden区分配

​	大多数情况下对象在新生代中eden区分配, 当eden区没有足够空间进行分配时,虚拟机将发起一次minorGC

​	__新生代GC(Minor GC)__ : 发生新生代的垃圾收集, 非常频繁,回收速度比较快

​	__老年代GC(Major GC/ Full GC): 发生在老年代的GC, 出现Major GC经常伴随至少一次的minor GC, Major GC一般会比Minor GC慢10倍以上



#### 2. 大对象直接进入老年代

​	大对象就是需要大量连续内存的空间对象(比如字符串 数组)

​	为了避免大对象为大对象分配内存时由于分配担保机制带来的复制而降低效率



#### 3. 长期存活的对象进入老年代

​	虚拟机给每个对象一个对象年龄(Age)计数器

​	如果对象在Eden出生并经过一次Minor GC后仍然存活, 并且能被Survivor容纳的话, 将被转移到Survivor空间中, 并将对象年龄设为1, 在Survivor每熬过一次minor GC, 年龄+1, 当年龄增加到一定程度(默认15岁), 就会被晋升到老年代, 可以通过参数 -XX: MaxTenuringThreshold来设置



#### 4. 动态对象年龄判断

​	虚拟机不是永远要求对象年龄必须到大某个值才能进入老年代, 如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般, 年龄大于或等于该对象就直接进入老年代



## 对象已经死亡?

​	堆中几乎存放所有对象的实例, 对堆垃圾回收前的第一步就是要判断哪些对象已经死亡

​	![image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/judge%20object%20death.png>)

	###  1. 引用计数法

​	给对象中添加一个引用计数器, 一个地方引用就+1, 引用失效 -1, 减到0就不能再被使用

​	**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。**

```Java
public class ReferenceCountingGc {
    Object instance = null;
	public static void main(String[] args) {
		ReferenceCountingGc objA = new ReferenceCountingGc();
		ReferenceCountingGc objB = new ReferenceCountingGc();
		objA.instance = objB;
		objB.instance = objA;
		objA = null;
		objB = null;
	}
}
```

​	objA和ojbB相互引用对象, 导致计数器都不为0

### 2. 可达性分析算法

​	通过一系列成为GC Roots的对象作为起点, 从这些节点开始向下搜索, 节点所走过的路径称为引用链, 当一个对象到GC Roots没有任何引用链相连的话,证明对象不可用

![image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/reachability%20analysis.jpeg>)

​		即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

​		被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

### 3.引用

无论哪种方法, 判断对象的存活都与引用有关

#### 1,强引用

​	类似必不可少的生活用品, 垃圾回收器绝不会回收它, 当内存空间不足时, 抛出OutOfMemoryError的错误,使程序异常终止.

#### 2. 软引用

​	可有可无的生活用品,  如果内存空间足够, 就不会回收它, 如不内存空间不足够, 就会回收这些对象的内存, 只要还没被回收,该对象就可以被程序引用, 软引用可用来实现内存敏感的高速缓存

​	软引用可以和一个引用队列联合使用, 如果软引用所引用的对象被垃圾回收, Java虚拟机就会把这个软引用加入到与之联合的引用队列中

#### 3. 弱引用

​	可有可无的生活用品, 弱引用于软引用的区别在于:只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

​	弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

#### 4. 虚引用

​	"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

​	**虚引用主要用来跟踪对象被垃圾回收的活动**。

​	**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

​	特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。



#### 5. 如何判断一个常量是废弃常量

​	运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？

​	假如在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。



#### 6. 如何判断一个类是无用的类

​		类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。

- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。



## 3. 垃圾收集算法

	#### 1. 标记-清除算法(mark sweep)

​	分为标记和清除阶段:首先标出所有需要回收的对象, 标记完成后统一回收所有被标记的对象, 是最基础的收集算法,有两个明显的问题:__效率问题__, __空间问题__

​	![image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/mark%20sweep.jpeg>)



#### 2. 复制算法(copying)

​	为了解决效率问题,"复制"收集算法出现了.它将内存分为大小相同的两块, 每次使用其中的一块. 当这一块的内存使用完成后,九江还存活的对象复制到一边去, 然后再把使用的空间一次清理掉.这样就使每次的内存回收都是对内存区间的一般进行回收.

​	![image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/copying.jpeg>)



#### 3.标记-整理算法(mark-compact)

​	标记过程与标记-清除算法一样, 但后续步骤不是直接对可回收对象回收,而是让所有的对象向一端移动,然后直接清理掉端边界以外的内存

​	![image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/mark%20compact.jpeg>)	

#### 4. 分代收集算法

​	根据年代选择合适的垃圾收集算法

​	**比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。**



## 垃圾收集器

​	我们能做的就是根据具体应用场景选择适合自己的垃圾收集器

#### 1. Serial 收集器

​	![image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/serial%20GC.jpeg>)	

​	简单高效, 单线程, 在进行垃圾收集工作的时候必须暂停其他所有的工作线程

#### 2. ParNew收集器

​	![image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/ParNew%20GC.jpeg>)

​	其实就是SerialGC的多线程版本, __新生代采用复制算法,老年代采用标记-整理算法__

​	它是许多运行在Server模式下虚拟机的首要选择,除了Serial收集器外, 只有它能和CMS收集器配合工作

​	__并行和并发__:

​		__并行(parallel)__: 指多条垃圾收集线程并行工作,但此用户线程仍然处于等待状态

​		__并发(Concurrent)__: 指用户线程与垃圾收集线程同时执行(但不一定是并行, 可能会交替执行),用户程序在继续运行,垃圾收集器运行在另一个CPU上

#### 3. Parrallel Scavenge 收集器

​	使用复制算法的多线程收集器, 看上去几乎和ParNew一样

```
-XX:+UseParallelGC 

    使用 Parallel 收集器+ 老年代串行

-XX:+UseParallelOldGC

    使用 Parallel 收集器+ 老年代并行
```

​	该收集器关注点是吞吐量(高效利用CPU). CMS等垃圾收集器的关注点更多是用户线程的停顿时间(提高用户体验).__吞吐量(throughput)就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值__

![image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/PParrallel%20Scavenge%20GC.jpeg>)

#### 4. Serial Old 收集器

​	Serial收集器的老年代版本, 同样是一个单线程收集器.两个用途: 一种在JDK1.5以及之前版本和Parallel Scavenge收集器搭配使用, 另一种作为CMS收集器的后备方案

#### 5. Parallel Old收集器

​	Parallel Scavenge收集器的老年代版本. 使用标记-整理算法

#### 6. CMS 收集器

​	CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器. 它非常符合在注重用户体验上的应用使用

​	CMS是HotSpot虚拟机第一款真正意义上的并发收集器, 它第一次实现了让垃圾收集线程与用户线程(基本)同时工作

​	是用__标记清除__算法实现,整个过程分为四个步骤:

- **初始标记：** 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ；

- **并发标记：** 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。

- **重新标记：** 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短

- **并发清除：** 开启用户线程，同时 GC 线程开始对为标记的区域做清扫。

  ![image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/CMS.jpeg>)

从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：**并发收集、低停顿**。但是它有下面三个明显的缺点：

- **对 CPU 资源敏感；**
- **无法处理浮动垃圾；**
- **它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。**



#### 7. G1 收集器

#### 	**G1 (Garbage-First) 是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时,还具备高吞吐量性能特征.**	被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征。它具备一下特点：

- **并行与并发**：G1 能充分利用 CPU、多核环境下的硬件优势，使用多个 CPU（CPU 或者 CPU 核心）来缩短 Stop-The-World 停顿时间。部分其他收集器原本需要停顿 Java 线程执行的 GC 动作，G1 收集器仍然可以通过并发的方式让 java 程序继续执行。
- **分代收集**：虽然 G1 可以不需要其他收集器配合就能独立管理整个 GC 堆，但是还是保留了分代的概念。
- **空间整合**：与 CMS 的“标记--清理”算法不同，G1 从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。
- **可预测的停顿**：这是 G1 相对于 CMS 的另一个大优势，降低停顿时间是 G1 和 CMS 共同的关注点，但 G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为 M 毫秒的时间片段内。

G1 收集器的运作大致分为以下几个步骤：

- **初始标记**
- **并发标记**
- **最终标记**
- **筛选回收**

**G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字 Garbage-First 的由来)**。这种使用 Region 划分内存空间以及有优先级的区域回收方式，保证了 GF 收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。

