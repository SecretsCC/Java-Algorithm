# JVM垃圾回收

## 常见面试题

 - 如何判断对象是否死亡(两种方法)
 - 强引用,弱引用,虚引用(弱引用与虚引用的区别,使用软引用带来的好处)
 - 如何判断一个常量是废弃常量
 - 如何判断一个类是无用的类
 - 垃圾收集有哪些算法,各自的特点
 - HotSpot为什么要分新生代和老年代
 - 常见的垃圾回收器有哪些
 - 介绍CMS,G1收集器
 - Minor Gc和Full GC有什么不同



## JVM内存分派与回收

​	内存自动管理主要真对对象内存回收和对象内存的分配, 核心功能是堆内存中对象的分配与回收

​	现在的收集器基本采用分代垃圾收集算法, Java堆细分为新生代和老年代, 在细致一点有Eden空间, From survivor, To survivor空间等, 进一步划分目的是更好的回收内存,或者更快的分配内存

​	__常见分配策略__

  		1. 对象优先在eden区分配
  		2. 大对象直接进入老年代
  		3. 长期存活的对象将进入老年代



#### 1. 对象优先在Eden区分配

​	大多数情况下对象在新生代中eden区分配, 当eden区没有足够空间进行分配时,虚拟机将发起一次minorGC

​	__新生代GC(Minor GC)__ : 发生新生代的垃圾收集, 非常频繁,回收速度比较快

​	__老年代GC(Major GC/ Full GC): 发生在老年代的GC, 出现Major GC经常伴随至少一次的minor GC, Major GC一般会比Minor GC慢10倍以上



#### 2. 大对象直接进入老年代

​	大对象就是需要大量连续内存的空间对象(比如字符串 数组)

​	为了避免大对象为大对象分配内存时由于分配担保机制带来的复制而降低效率



#### 3. 长期存活的对象进入老年代

​	虚拟机给每个对象一个对象年龄(Age)计数器

​	如果对象在Eden出生并经过一次Minor GC后仍然存活, 并且能被Survivor容纳的话, 将被转移到Survivor空间中, 并将对象年龄设为1, 在Survivor每熬过一次minor GC, 年龄+1, 当年龄增加到一定程度(默认15岁), 就会被晋升到老年代, 可以通过参数 -XX: MaxTenuringThreshold来设置



#### 4. 动态对象年龄判断

​	虚拟机不是永远要求对象年龄必须到大某个值才能进入老年代, 如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一般, 年龄大于或等于该对象就直接进入老年代



## 对象已经死亡?

​	堆中几乎存放所有对象的实例, 对堆垃圾回收前的第一步就是要判断哪些对象已经死亡

​	![image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/judge%20object%20death.png>)

	###  1. 引用计数法

​	给对象中添加一个引用计数器, 一个地方引用就+1, 引用失效 -1, 减到0就不能再被使用

​	**这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。**

```Java
public class ReferenceCountingGc {
    Object instance = null;
	public static void main(String[] args) {
		ReferenceCountingGc objA = new ReferenceCountingGc();
		ReferenceCountingGc objB = new ReferenceCountingGc();
		objA.instance = objB;
		objB.instance = objA;
		objA = null;
		objB = null;
	}
}
```

​	objA和ojbB相互引用对象, 导致计数器都不为0

### 2. 可达性分析算法

​	通过一系列成为GC Roots的对象作为起点, 从这些节点开始向下搜索, 节点所走过的路径称为引用链, 当一个对象到GC Roots没有任何引用链相连的话,证明对象不可用

![image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/reachability%20analysis.JPEG>)

​		即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。

​		被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

### 3.引用

无论哪种方法, 判断对象的存活都与引用有关

#### 1,强引用

​	类似必不可少的生活用品, 垃圾回收器绝不会回收它, 当内存空间不足时, 抛出OutOfMemoryError的错误,使程序异常终止.

#### 2. 软引用

​	可有可无的生活用品,  如果内存空间足够, 就不会回收它, 如不内存空间不足够, 就会回收这些对象的内存, 只要还没被回收,该对象就可以被程序引用, 软引用可用来实现内存敏感的高速缓存

​	软引用可以和一个引用队列联合使用, 如果软引用所引用的对象被垃圾回收, Java虚拟机就会把这个软引用加入到与之联合的引用队列中

#### 3. 弱引用

​	可有可无的生活用品, 弱引用于软引用的区别在于:只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

​	弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

#### 4. 虚引用

​	"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

​	**虚引用主要用来跟踪对象被垃圾回收的活动**。

​	**虚引用与软引用和弱引用的一个区别在于：** 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

​	特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。



#### 5. 如何判断一个常量是废弃常量

​	运行时常量池主要回收的是废弃的常量。那么，我们如何判断一个常量是废弃常量呢？

​	假如在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。



#### 6. 如何判断一个类是无用的类

​		类需要同时满足下面 3 个条件才能算是 **“无用的类”** ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
- 加载该类的 ClassLoader 已经被回收。

- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。



## 3. 垃圾收集算法

	#### 1. 标记-清除算法(mark sweep)

​	