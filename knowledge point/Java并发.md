# Java并发面试

## 进程和线程

#### 进程

​	进程是程序一次执行过程,是系统运行程序的基本单位,因此进程是动态的。系统运行一个程序即是一个进程从创建,运行到消亡的过程

​	在Java中,启动main函数时,其实就是启动了一个JVM进程, 而main函数所在的线程就是这个进程中的一个线程,也称为主线程

#### 线程

​	线程是一个比进程更小的执行单位。一个进程在其执行过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源,但每个线程有自己的程序计数器,虚拟机栈,本地方发栈,所以系统产生一个线程,或是在各个线程之间切换工作时,负担要比进程小得多。



## 线程与进程的关系,区别和优缺点

​	思考: 为什么PC,JVM stack, local method stack是私有的,堆和方法区是线程共享的呢?

​	**程序计数器:** 线程切换后能恢复到正确的执行位置

​	**虚拟机栈:** 每个Java方法在执行的同时会创建一个栈帧用于存储局部变量表,操作数栈,常量池引用等信息。从方法调用直至执行完成的过程,就对应着一个栈帧在Java虚拟机中入栈和出栈的过程

​	**本地方法栈:** 为虚拟机使用到的Native方法服务

​	为了保证线程中的局部变量不被别的线程访问到,虚拟机栈和本地方发栈是线程私有的



​	**堆,方法区:**堆主要存放新城建的对象(对象在这里分配内存), 方法区主要用于存放已被加载的类信息,常量,静态变量.即使编译器编译后的代码等数据



## 并发和并行

​	**并发:** 同一时间段,多个任务都在执行(单位时间内不一定同时执行)

​	**并行**: 多个任务同时执行

#### 为什么使用多线程

​	**从计算机底层来说,**线程间的切换和调度成本远小于进程。多核CPU时代意味着多个线程可以同时运行,减少了线程上下文切换的开销

​	**互联网发展趋势来说,**多线程大大提高系统整体的并发能力以及性能



#### 多线程带来的问题

​	并发编程可能会一起内存泄漏,上下文切换,死锁还有受限于硬件和软件资源闲置问题



## 线程生命周期和状态

​	![Image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/Thread%20state.png>)

​	线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。

​	![Image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/Thread%20instance.png>)

​	上图可看出: 线程创建之后将处于NEW状态,调用start()方法后开始运行,线程这时候处于READY状态,可运行的线程获取了CPU的时间片后处于RUNNING状态。当执行wait()方法后,线程进入WAITING状态。进入等待状态的线程需要依靠其他线程的通知才能够返回运行状态, 而TIME_WAITING状态相当于在等待状态的基础上增加了超时限制,比如sleep(long millis)方法或wait(long millis)方法可以将Java线程置于TIMED WAITING状态,当等待到超时时间后Java线程返回到RUNNABLE状态。当线程调用同步方法时, 在没有获取到锁的情况下,线程将会进入到BLOCKED阻塞状态,线程在执行RUNNABLE的run()方法之后将会进入到TERMINATED状态



## 上下文切换

​	多线程编程一般线程个数都大于CPU个数,而一个CPU在任意时刻只能被一个线程使用,为了让线程能得到有效的执行,CPU采取的策略是为每个线程分配时间片并轮转的形式,当一个线程的时间片用完就会重新处于就绪状态让其他线程使用,这个过程就属于一次上下文切换

​	任务从保存到再加载的过程就是一次上下文切换



## 死锁,如何避免

​	多个线程同时被阻塞,他们中的一个或全部都在等某个资源被释放。由于线程被无限期的阻塞,因此程序不可能正常终止

​	![Image text](<https://github.com/SecretsCC/Java-Algorithm/blob/master/knowledge%20point/images/Dead%20block.png>)



学过操作系统的朋友都知道产生死锁必须具备以下四个条件：

1. 互斥条件：该资源任意一个时刻只由一个线程占用。
2. 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
3. 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。
4. 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。



**如何避免**

​	只要破坏死锁四个条件中的一个就可以了

​	**破坏互斥条件:** 这个没办法破坏,因为用锁本来就是让他们互斥

​	**破坏请求与保持条件:** 一次性申请所有的资源

​	**破坏不剥夺条件:** 占用部分资源的线程进一步申请其他资源时,如果申请不到,可以主动释放它占有的资源

​	**破坏循环等待条件:** 靠按序申请资源来预防,按某一顺序申请资源,释放资源则反序释放,破坏循环等待条件



## sleep()方法和wait()方法区别和共同点

​	sleep方法没有释放锁,而wait方法释放了锁

​	两者都可以暂停线程的执行

​	Wait通常被用于线程间交互/通信,sleep通常被用于暂停执行

​	wait()方法被调用后,线程不会自动苏醒,需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后,线程会自动苏醒,或者可以使用wait(long timeout)超时后线程会自动苏醒



## 为什么我们调用start()方法时会执行run()方法,为什么我们不能直接调用run()方法

​	new 一个Thread, 线程进入了新建状态,调用start()方法, 会启动一个线程并使线程进入了就绪状态, 当分配到时间片后就可以开始运行了。start()会执行线程响应的准备工作,然后自动执行run(), 这是真正的多线程工作。而直接执行run()方法,会把run方法当成一个main线程下的普通方法去执行,并不会在某个线程中执行它,所以并不是多线程

**总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**